/*
[1] find variable replaced value : DONE
[2] return true  if any special characters and space added between word and charcters,
 but 
[3] return false if words missing or any characters is missing from word
[4] return false if any additional charcters addedd between word
[5] return false if modified content all word sequence is not 
matching with original content except variable replaced value
*/

//[1] if any word is missing, if any characters and word is missing, if any word is mis-matched
// function checkContentMatch(approvedContent,originalContent) {
//     // Convert template placeholders (e.g., {{1}}, {{2}}, etc.) to a wildcard pattern (.*)
//     const regexPattern = approvedContent.replace(/\{\{\d+\}\}/g, "(.*)");

//     // Create a regular expression from the modified template pattern
//     const regex = new RegExp(`^${regexPattern}$`);

//     // Test if the content matches the pattern
//     if (regex.test(originalContent)) {
//       return { isMatched: true };
//     } else {
//       return { isMatched: false };
//     }
//   } //if above function returns true then no need to check other values if false then only check extra charcters or numbers 
// replace speacial charcaters---

// [2] replace special characters with empty string
// [3] return rest content except replaced words with variables
// will return empty array if other content changed except variables
function findReplacements(originalContent, modifiedContent) {
  // Step 1: Create a regular expression pattern from originalContent with placeholders as capture groups
  const regexPattern = originalContent.replace(/\{\{\d+\}\}/g, "(.*?)");
  const regex = new RegExp(`^${regexPattern}$`);

  // Step 2: Match the modifiedContent against the constructed pattern
  const match = modifiedContent.match(regex);

  const replacements = [];
  // Step 3: Check if there's a match and extract replacements
  if (match) {
      // Collect replacements for each placeholder (excluding the full match at index 0)
      
      let placeholderIndex = 1;
      for (let i = 1; i < match.length; i++) {
          replacements.push(match[i]);
          placeholderIndex++;
      }
  }
  return replacements

  // return rest content except replaced words with variables
    // return replacements.reduce((result, word) => result.replace(new RegExp(word, 'g'), ''), modifiedContent).replace(/\s{2,}/g, ' ').trim();

}

//  find variable surrounding words,
// function findSurroundingWords(sentence) {
//   const words = sentence.split(' ');

//   let result = [];
  
//   for (let i = 0; i < words.length; i++) {
//     const word = words[i];
//     if (/\{\{\d+\}\}/.test(word)) {
//       result.push({
//         before: words[i - 1],
//         after: words[i + 1]
//       });
//     }
//   }

//   return result;
// }
// const variable = "{{1}}";

// const result = findSurroundingWords(sentence);
// console.log("rRES",result); // Output: ["आमच्या", "निदर्शनास"]


//[4] get content except replaced variable
function removeContentBetweenWords(originalContent, modifiedContent) {

  //1. find surrounding words of variables
  const words = originalContent.split(' ');

  let pairs = [];
  
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    if (/\{\{\d+\}\}/.test(word)) {
      pairs.push({
        before: words[i - 1],
        after: words[i + 1]
      });
    }
  }

  // const pairs = [
  //   { before: "आमच्या", after: "निदर्शनास" },
  //   { before: "आहे", after: "आनि" },
  //   { before: "आनि", after: undefined }
  // ];

//2. Remove variable replaced values to get rest value
  let modifiedText = modifiedContent;

  for (let i = 0; i < pairs.length; i++) {
    const { before, after } = pairs[i];

    if (!after) {
      // If 'after' is undefined, remove everything after 'before'
      const regex = new RegExp(`${before}(.*)`);
      modifiedText = modifiedText.replace(regex, before);
      break; // Break the loop as we've processed the last pair
    }

    const regex = new RegExp(`${before}(.*?)${after}`, 'g');
    modifiedText = modifiedText.replace(regex, before +" "+ after);
  }

  // function removeSpecialCharactersExceptCommasAndPeriods(str) {
    modifiedText.replace(/[!@#$%^&*()_+-\|?/<>]/g, "");
  // }

  return modifiedText;
}

const sentence = "प्रिय कर्मचारी, आमच्या {{1}} निदर्शनास आले आहे {{2}} आनि {{3}}";
const text = "प्रिय कर्मचारी, - / \&आमच्या  आले hjhhjd निदर्शनास आले आहे hghghghghg आनि lasttttttt here";
// const res = removeContentBetweenWords(sentence, text);
// console.log("removeContentBetweenWords",{org:sentence,  res}); // Output: प्रिय कर्मचारी, आमच्या निदर्शनास आले आनि lasttttttt here

console.log("REPLAC",text.replace(/[!@#$%^&*()_+-\|?/<>]/g, ""));

// ///////////////////////////////////////////////////////////////////////////////////

// Example usage
const originalContent = "प्रिय कर्मचारी, आमच्या {{1}} निदर्शनास आले आहे {{2}} आनि {{3}}";
const modifiedContent = "प्रिय कर्मचारी, आमच्या jhjh आ ले निदर्शनास आले आ हे आलेआले आनि jhjh jhjh";

console.log(findReplacements(originalContent, modifiedContent));
// Expected output: { "{{1}}": "jhjh आले", "{{2}}": "आलेआले" }



const regex = /\{\{\d+\}\}/g;
const contentWithoutVariables = originalContent.replace(regex, '');
const restContent = findReplacements(originalContent, modifiedContent);

console.log("REST", restContent)

// Example usage
// console.log(replaceSpacesWithUnderscores("प्रिय कर्मचारी, आमच्या {{1}} निदर्शनास आले आहे {{2}}", "प्रि&य कर्मचारी, आ मच्या {{1}} निदर्शनास आले आहे {{2}}")); // Expected output: { isMatched: true }
// console.log(checkContentMatch("प्रिय कर्मचारी, आमच्या {{1}} निदर्शनास आले आहे {{2}}", "प्रिय कर्मचारी, आमच्या निदर्शनास आले आहे")); // Expected output: { isMatched: true }
// console.log(checkContentMatch("प्रिय कर्मचारी, आमच्या {{1}} निदर्शनास आले आहे {{2}}", "प्रिय कर्मचारी, आमच्या निद9र्शनास आले आहे")); // Expected output: { isMatched: false }

